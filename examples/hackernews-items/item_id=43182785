{"by": "Jach", "id": 43182785, "kids": [43187481], "parent": 43149750, "text": "A late reply but it&#x27;s worth addressing one way of doing this. First, your concern about object not being a valid function or macro isn&#x27;t relevant at read time. Second, note that Lisp already has similar syntax: &#x27;(1 . 2) is essentially (cons 1 2). Implementing this type of syntax is not a privilege of the implementation alone. You&#x27;re allowed to redefine your own reader for left paren. In SBCL:<p><pre><code>    CL-USER&gt; (get-macro-character #\\()\n    SB-IMPL::READ-LIST\n</code></pre>\nYou can write `(set-macro-character #\\( &#x27;sb-impl::read-list)` and everything continues to work just fine. You can also jump-to-source and modify it if you want -- though it&#x27;s cleaner to just copy it out to your own project, that&#x27;s what I did for a quick hack&#x2F;proof of concept. Essentially I added before the existing (when...) which handles the special dot syntax:<p><pre><code>      (when (and (eq firstchar #\\-)\n                 (eq (peek-char t stream t nil t) #\\&gt;))\n        (read-char stream t) ; actually read the nextchar &gt; to discard it\n        (let ((next-obj (read stream)))\n          (sb-impl::flush-whitespace stream rt)\n          (return `(slot-value ,@listtail &#x27;,next-obj))))\n</code></pre>\nI won&#x27;t claim this is good or proper, but it shows that it&#x27;s quite feasible. We&#x27;ve turned (foo -&gt; bar) into (slot-value foo &#x27;bar).<p><pre><code>    CL-USER&gt; (defclass vec2 ()\n      ((x :initarg :x)\n       (y :initarg :y)))\n    #&lt;STANDARD-CLASS COMMON-LISP-USER::VEC2&gt;\n    CL-USER&gt; (defparameter vec (make-instance &#x27;vec2 :x 3 :y 4))\n    VEC\n    CL-USER&gt; (vec -&gt; y)\n    4\n    CL-USER&gt; (read-from-string &quot;(print (vec -&gt; x))&quot;)\n    (PRINT (SLOT-VALUE VEC &#x27;X))\n    18\n</code></pre>\nPersonally I wouldn&#x27;t use this even if it was more properly&#x2F;carefully implemented. (There&#x27;s really no reason to replace the default left-paren reader, and no reason we have to have a space surrounding the &quot;-&gt;&quot;. One thing I like about the infix reader macro package <a href=\"https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;cmu-infix\">https:&#x2F;&#x2F;github.com&#x2F;quil-lang&#x2F;cmu-infix</a> is that it doesn&#x27;t care about spaces, I can write #I(1+1 + 4) and get 6.) I&#x27;m quite happy putting my class in its own package, and thus getting the primary tab-completion behavior I care about. e.g. &quot;(ma:&lt;tab&gt;&quot; could complete to &quot;(math:&quot; and then &quot;(math:v&lt;tab&gt;&quot; could complete to a list of options like &quot;vector-x&quot; &quot;vector-y&quot; or so on. I also like the somewhat unusual approach of naming my accessors with a dot prefix, e.g. (.x vec) and (.y vec), or even (math:.x vec) if I haven&#x27;t imported the symbol.", "time": 1740570183, "type": "comment"}